---
title: "Data 622 - Homework #4 (Group 2)"
author: "Mengqin Cai, Zhi Ying Chen, Donny Lofland, Grace Han, Zach Alexander"
date: "5/7/2021"
output: 
  html_document:
    theme: cerulean
    highlight: pygments
    css: ./lab.css
    toc: true
    toc_float: true
    code_folding: hide
  pdf_document:
    extra_dependencies: ["geometry", "multicol", "multirow", "xcolor"]
---

Source Code: [https://github.com/djlofland/DATA622_S2021_Group2/tree/master/Homework4](https://github.com/djlofland/DATA622_S2021_Group2/tree/master/Homework4)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r, include=FALSE}
library(readxl)           # Y Read Excel Data

require(naniar)
library(skimr)
require(VIM)
library(imputeTS)

library(doParallel)   # Leverage multiple cores for ML

require(MASS)
require(gbm)
require(xgboost)
library(forecast)
require(rpart)
require(rpart.plot)
require(randomForest)
require(caret)
require(pROC)

library(tidyverse)        # TIDY packages
library(dplyr)   # dplyr has to be loaded before tidyr
library(tidyr)

require(ggplot2)
require(GGally)
require(tidyr)
require(Amelia)
require(psych)
require(class)
require(tree)
require(knitr)
require(kableExtra)
require(mice)

library(corrplot)
library(RColorBrewer)
library(broom)
library(cluster)
library(factoextra)
library(NbClust)
library(dendextend)

library(e1071)
```


For this assignment, we will be working with a very interesting mental health dataset from a real-life research project. All identifying information, of course, has been removed. The attached spreadsheet has the data (the tab name “Data”). The data dictionary is given in the second tab. You can get as creative as you want. The assignment is designed to really get you to think about how you could use different methods.

***

## **Load Data & EDA**

***

### Load Data

We start by loading the Excel dataset provided into a dataframe.

```{r, echo=FALSE}
# Load data
df <- read_excel('data/ADHD_data.xlsx')
```


#### Data Sample

Next, we can take a quick look at the dataframe features. By highlighting the data dictionary below, and printing the first few rows, we can start to establish some context around the data that has been collected from the survey.

```{r}
# Display first few rows for inspection
kable(head(df)) %>% 
  kable_styling(bootstrap_options = "basic")
```

#### Data Dictionary

* **Initial** *Respondents initial*:  we will drop this column
* **Age** *Age*:  0 ... 69
* **Sex** *Sex*:  Male-1, Female-2
* **Race** *Race*:  White-1, African American-2, Hispanic-3, Asian-4, Native American-5, Other or missing data -6
* **ADHD Q(n)** *ADHD self-report scale*: Never-0, rarely-1, sometimes-2, often-3, very often-4
* **ADHD Total** *ADHD self-report Total*: Sum of ADHD question scores
* **MD Q(n)** *Mood disorder questions*: No-0, yes-1; question 3: no problem-0, minor-1, moderate-2, serious-3
* **MD TOTAL** *MD self-report Total*: Sum of MD question scores
* **Alcohol**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **THC**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Cocaine**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Stimulants**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Sedative-hypnotics**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Opioids**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Court order** *Court Order*:  No-0, Yes-1
* **Education** *Education*: 1-12 grade, 13+ college
* **Hx of Violence** *History of Violence*: No-0, Yes-1
* **Disorderly Conduct** *Disorderly Conduct*: No-0, Yes-1
* **Suicide** *Suicide attempt*: No-0, Yes-1
* **Abuse** *Abuse Hx*: No-0, Physical (P)-1, Sexual (S)-2, Emotional (E)-3, P&S-4, P&E-5, S&E-6, P&S&E-7
* **Non-subst Dx** *Non-substance-related Dx*: 0 – none; 1 – one; 2 – More than one
* **Subst Dx** *Substance-related Dx*: 0 – none; 1 – one Substance-related; 2 – two; 3 – three or more
* **Psych meds.** *Psychiatric Meds*: 0 – none; 1 – one psychotropic med; 2 – more than one psychotropic med


#### Data Frame summary

After reading in the dataframe and identifying the data dictionary that explains the values for our features, our next step is to do some exploratory analysis. We can initially run the `skim()` function to find important generalized information about the dataset.

```{r}
# Show df summary deatils
skim(df)
```
We can see above that the dataset consists of 175 observations and 54 different features. A few of the features have quite a few missing values, including the `Psych meds.` feature (with 118 missing values), as well as `Subst Dx` and `Non-subst Dx`, which have 23 and 22 missing values, respectively. These questions, when looking at the data summary above, correspond to medication questions that are specific to a particular population -- for instance, when sampling the general population for a survey, likely a smaller percentage (and not a majority) will be on psychiatric medication, or be taking medication for substance use/non-substance use related causes. Therefore, many of these missing values make sense, but will be important to keep in mind when we start our clustering techniques.  

Another interesting component of the `skim()` function is to be able to take a quick look at the distribution of responses for each feature. From the `Education` distribution, we can see that the median education level was a high school diploma (12th grade). Also, there seemed to be slightly more males than females that responded to the survey, and the median age was around 42 years. Additionally, we can see that a majority of respondents to many of the substance use questions, such as `Cocaine`, `THC` and `Alcohol` tended to answer as either "no use", or "dependence", with not much gray area in between. Finally, a large majority of respondents self-identified their race as White.  


### Missing Values

As we saw in our data summary, we have some missing values.  Lets explore this a little further to see if any important patterns stand out.  

```{r}
# Use nanair package to plot missing value patterns
gg_miss_upset(df)
```

The missing data only appears in a few of our features: `Suicide`, `Abuse`, `Non-subst Dx`, `Subst Dx`, and `Psych meds.`.

For factors, doing traditional imputing approaches can be problematic.  While in most cases, missing data might be inferred as 0, we don't know if there were problems with administering, coding the survey, and/or patients didn't want to answer and skipped questions (when some of these may have applied).  So, rather than dropping the rows or imputing, we will instead create new factor values 'NA' for each indicating that we lack that information. 

We also see that for each respondent, we have their initial.  This won't be useful for our purposes (note there are also duplicates where multiple people had the same initials).

```{r}
# Replace missing with 'unknown' so we have a factor value for each
#df <- df %>% 
  #na_replace('unknown')

# Drop Initial column
#df <- df %>% 
  #dplyr::select(-Initial)

## Use kNN to impute the data
df<-kNN(df)%>%
  select(Age:'Psych meds.')

```

Looking at our dataset, we see that missing values are no longer an issue; however, we still have some additional cleanup to perform on our dataset below before we proceed with kNN modeling.   

```{r}
# Display data from summary
skim(df)
```

#### Fix Datatypes

We know that most of our features are either factors or ordinal factors.  Let's recode from `float` to `factor` to ensure our models don't incorrectly treat them as continuous.  Note that we'll leave `Age` as continuous even though it's technically an ordinal factor.  Also, for simplicity, `boolean` features (only 0 or 1) can be left as `integer`.  Looking ahead, factors are going to lead to a large number of features when we dummy code in preparation for modeling.  Dummy encoding leads to separate columns for each value.  High dimensions can lead to problems [TODO: insert discussion as to why here].  Fortunately, we don't have that many features and values, so we aren't starting with an excessive number of coumns.  That said, we will likely need to either reduce dimensions thorough PCA or different recoding approaches.  

```{r}
# We'll leave age as an integer
df$Age                  <- as.integer(df$Age)

# Misc columns (note: some columns are ordinal, others are not)
df$Sex                  <- factor(df$Sex)
df$Race                 <- factor(df$Race)
df$Alcohol              <- factor(df$Alcohol)
df$THC                  <- factor(df$THC)
df$Cocaine              <- factor(df$Cocaine)
df$Stimulants           <- factor(df$Stimulants)
df$`Sedative-hypnotics` <- factor(df$`Sedative-hypnotics`)
df$Opioids              <- factor(df$Opioids)

df$Education            <- factor(df$Education)

df$`Court order`        <- factor(df$`Court order`)
df$`Hx of Violence`     <- factor(df$`Hx of Violence`)
df$`Disorderly Conduct` <- factor(df$`Disorderly Conduct`)
df$Suicide              <- factor(df$Suicide)

df$Abuse                <- factor(df$Abuse)

df$`Non-subst Dx`       <- factor(df$`Non-subst Dx`)
df$`Subst Dx`           <- factor(df$`Subst Dx`)
df$`Psych meds.`        <- factor(df$`Psych meds.`)

# Quick trick to fix all columns matching name pattern
df <- df %>%
  mutate(across(contains('ADHD'), factor)) %>%
  mutate(across(contains('MD Q'), factor))

# Back these out since they are totals (sum), not factor
df$`ADHD Total`         <- as.integer(df$`ADHD Total`)
df$`MD TOTAL`           <- as.integer(df$`MD TOTAL`)
```

### Feature Plots

For the continuous variables, we can examine the distributions, broken out by the target variable, `Sex`.  

[TODO: This was quick and dirty placeholder ... Provide better visualizations, possibly by feature category (e.e.g, ADHD, MD, Substance Abuse columns, etc)]

```{r, fig.height = 6, fig.width = 6}

df_plot = df %>% mutate(Sex = ifelse(Sex == 1, "Male", "Female"))

par(mfrow=c(2,3))
par(oma=c(0,0,6,0))


tbl1 <- table(df_plot$Sex, df_plot$Alcohol)
barplot(tbl1, main="Alcohol use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)), legend=TRUE)

tbl2 <- table(df_plot$Sex, df_plot$Cocaine)
barplot(tbl2, main="Cocain use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl3 <- table(df_plot$Sex, df_plot$THC)
barplot(tbl3, main="THC use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl4 <- table(df_plot$Sex, df_plot$Stimulants)
barplot(tbl4, main="Stimulant use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl5 <- table(df_plot$Sex, df_plot$`Sedative-hypnotics`)
barplot(tbl5, main="Sedative-hypnotic use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl6 <- table(df_plot$Sex, df_plot$Opioids)
barplot(tbl6, main="Opioid use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))


title("(0 = No use, 1 = Use, 2 = Abuse, 3 = Dependence)" , outer=TRUE)
par(oma=c(1,0,3,0))
title("SUBSTANCE USE RESPONSES BY SEX" , outer=TRUE)


```
```{r, fig.height=3, fig.width=6}

myColors <- ifelse(df_plot$Sex=="Male" , "thistle3", "cornflowerblue")

par(mfrow=c(1,2))
boxplot(df_plot$`ADHD Total`~df_plot$Sex, xlab="", ylab = "ADHD Total", main="ADHD Totals by Sex", col=myColors)
boxplot(df_plot$`MD TOTAL`~df_plot$Sex, xlab="", ylab = "MD Total", main="MD Totals by Sex", col=myColors)
```

```{r, fig.height=8, fig.width=6}
par(mfrow=c(2,2))
par(oma=c(0,0,6,0))

tbl7 <- table(df_plot$Sex, df_plot$`Court order`)
barplot(tbl7, main="Court order",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl8 <- table(df_plot$Sex, df_plot$`Hx of Violence`)
barplot(tbl8, main="History of violence",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl9 <- table(df_plot$Sex, df_plot$`Disorderly Conduct`)
barplot(tbl9, main="Disorderly conduct",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl11 <- table(df_plot$Sex, df_plot$Suicide)
barplot(tbl11, main="Suicide",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)), legend=TRUE)


title("(0 = No, 1 = Yes)" , outer=TRUE)
par(oma=c(1,0,3,0))
title("MENTAL HEALTH AND JUSTICE INVOLVEMENT BY SEX" , outer=TRUE)
```


```{r, fig.height=6, fig.width=6}

par(mfrow=c(1,1))
par(oma=c(4,0,0,0))

df_plot = df_plot %>% mutate(Abuse = ifelse(Abuse == 0, "None", 
                              ifelse(Abuse == 1, "Physical (P)", 
                              ifelse(Abuse == 2, "Sexual (S)", 
                              ifelse(Abuse == 3, "Emotional (E)",
                              ifelse(Abuse == 4, "P & S", 
                              ifelse(Abuse == 5, "P & E", 
                              ifelse(Abuse == 6, "S & E", 
                              ifelse(Abuse == 7, "P & E & S", "Unknown")))))))))

tbl10 <- table(df_plot$Sex, df_plot$Abuse)
barplot(tbl10, main="Abuse",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)), las=2, legend=TRUE)
```


When looking at these figures broken out by our target variable `Sex`, we can see a few things:  

+ Interestingly, it appears that female respondents had an ADHD total score that was trending higher than male respondents.  

+ MD totals were similar across both male and female respondents.  

+ It appears that both male and female respondents answered "No use", more frequently for substances such as stimulants, sedative-hypnotics, and opioids, than for some of the more common drugs, such as alcohol, THC, and cocaine.  

+ It also looks like males responded more frequently as having a history of violence, or disorderly conduct.  

+ Conversely, it looks like females responded slightly more frequently than males as having attempted suicide.  

+ Finally, when looking closely at the breakdown of responses to the Abuse question by sex, we can see that females overwhelmingly responded more frequently of having experienced some form of abuse, especially sexual abuse or a combination of sexual abuse with other forms of abuse. This was noticeably more frequent than the responses by their male counterparts.


[TODO: Insert CorrPlot?  Since he have high dimensions, it may be problematic to visualize.  Maybe if we facet?  not sure]

Placeholder (and useless) image inserted below.  

```{r}
library(ggcorrplot)
model.matrix(~., data=df) %>% 
  cor(use="pairwise.complete.obs") %>% 
  ggcorrplot(show.diag = F, type="lower", lab=TRUE, lab_size=2)
```

[Zach comment: I also tried to find a better way to visualize this, but came up empty. I did attempt a distance plot, but similar to yours above, there seem to be too many dimensions. My code below is pretty useless, but wanted to keep it in just in case it spurred other ideas.]

```{r}
library(factoextra)
distance <- get_dist(df)
fviz_dist(distance, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
```



[TODO: Describe any clear feature distributions or correlations patterns] 

### Dummy Columns

We’ll need to dummy code our categorical variables.  This process will create new columns for each value and assign a 0 or 1.  Note that dummy encoding typically drops one value which becomes the baseline.  So if we have a categorical feature with five unique values, we will have four columns.  If all columns are 0, that represents the reference value.  This helps reduce the number of necessary columns.  With dummy columns in place, we need to remove our original variables from this dataset. 

```{r}
# dummy encode our categorical features
df_dummy <- dummyVars(~ 0 + ., drop2nd=TRUE, data = df)
df_dummy <- data.frame(predict(df_dummy, newdata = df))

# Uncomment if we want to verify the dummy df summary
#skim(df_dummy)
```

### (Near) Zero Variance

We should remove any columns with zero variance.  Note, since we are working with a sparse dataset, we do NOT want to remove **near** zero variance, just **zero** variance.

```{r}
nzv <- nearZeroVar(df_dummy, saveMetrics= TRUE)
(nzv %>% filter(zeroVar == T))

# drop columns with zero variance
nzv <- nearZeroVar(df_dummy)
df_dummy <- df_dummy[, -nzv]
```


[TODO: Should we revisit correlations between factor variable?  Describe any clear feature distributions or correlations patterns] 

### Feature Correlation

[TODO: Show feature value correlations]

[TODO: Discuss multicolineatity and determine if any features are candidates to be dropped up front.]

### Class imbalance

If values within factors are highly imbalanced, then we can get bias where specific values are better represented and thus algorithms have more datapoints to learn from.  

[TODO: If any strong class imbalance of values with in a feature, we might need to bootstrap or resample to address]

Next, we'll do some data tidying to get our data set ready for our KNN model. [TODO: Insert discussion on any features to remove, keep, data type changes, needs transforms, etc]  

```{r}
# remove any features
#df <- df %>% 
#  dplyr::select(-c())
```

### Transforms

`Age` is our only continuous variable.  We normalize our continuous features using a simple z-score standardization.  Although this may help our KNN model, we’ll have to be careful about interpretability later on!

```{r}
# z-score scale continuous features
df[, c("Age")] <- scale(df[, c("Age")])
```

Our data set is ready for our unsupervised models.  

```{r, warning=FALSE, message=FALSE}
# quick inspect of dataframe
kable(head(df_dummy)) %>% 
  kable_styling(bootstrap_options = "basic")
```


***

## **Part 1: Cluster Patients**

***

Please use a clustering method to find clusters of patients here.  Whether you choose to use k-means clustering or hierarchical clustering is up to you as long as you reason through your work. Can you come up with creative names for the profiles you found? *(60)*

### K-Means

Now that our data has been tidy'd and is ready to be subjected to a few unsupervised learning techniques, we'll first start with a k-means approach. The k-means algorithm works via the following steps:  

+ First, a certain number of clusters (k) is designated, and the algorithm obtains all observations and creates k random unnamed/new observations that serve as initial "centroids".  

+ These centroids are then used to compute the Euclidean distance between the centroid and the surrounding observations. For each observation, the nearest centroid is used to classify the observation, and will essentially assign a category.  

+ Then, the algorithm takes the average of all of the points in each category and recomputes the centroid based on this average. The algorithm then runs again using these new centroids.  

+ The process ends when there is no change in centroid position between one run of the clustering algorithm and another.  

For our dataset, we'll essentially subject our k-means algorithm directly to our dataset. However, for a k-means approach, you'll first have to assign the number of final clusters you'd like to classify your data into. This can be a difficult task, thus we will outline this process below.

#### Determine Segments

We'll need to identify the appropriate number for `k`. `k` represents the number of clusters we will group rows into.  Three common techniques are: Elbow, Silhouette, Gap statistic, and NBClust().  For simplicity, we will uyse the Elbow approach.  [TODO: Insert disscussion]  

```{r}
# Elbow method
fviz_nbclust(df_dummy, kmeans, method = "wss") +
  geom_vline(xintercept = 4, linetype = 2) + # add line for better visualization
  labs(subtitle = "Elbow method") # add subtitle
```

We can see above, that it is approximately 5. More clusters do not improve within segment variability.  Therefore, we’ll perform our initial K-Means model with $k=5$.

#### Build Model

```{r}
set.seed(42)
km_res <- kmeans(df_dummy, centers = 5, nstart = 20)

summary(km_res)

sil <- silhouette(km_res$cluster, dist(df_dummy))
fviz_silhouette(sil)

```

After running our `kmeans()` function, we can take a look at the final 5 clusters that were created by our algorithm:  
As a reminder, the interpretation of the silhouette coefficient is as follows:

1, >0, means that the observation is well grouped. The closer the coefficient is to 1, the better the observation is grouped.

2, <0, means that the observation has been placed in the wrong cluster.

3, =0, means that the observation is between 5 clusters.

The silhouette plot above and the average silhouette coefficient help to determine whether your clustering is good or not. If a large majority of the silhouette coefficients are positive, it indicates that the observations are placed in the correct group. This silhouette plot can therefore be used in the choice of the optimal number of classes.

It is also possible to plot clusters by using the fviz_cluster() function. Note that a principal component analysis is performed to represent the variables in a 5 dimensions plane.
```{r}
fviz_cluster(km_res, df_dummy, ellipse.type = "norm")
```
To provide some context around the clusters that were generated by our algorithm, we decided to isolate the 5 clusters we created, and subjected them to our `df_dummy` dataset, grouping and computing the means for each one of our features, to see if any noticeable trends start to arise. 
```{r}
k_means_analysis_df <- df_dummy %>%
  mutate(Cluster = km_res$cluster) %>%
  group_by(Cluster) %>%
  summarise_all("mean")
```

```{r}
k_means_analysis_df <- k_means_analysis_df %>% select('Cluster', 'Age', 'Sex.1', 'X.ADHD.Total.', 'X.MD.TOTAL.', 'Alcohol.0', 'Alcohol.3', 'THC.0', 'THC.3', 'X.Court.order.1', 'X.Hx.of.Violence.1', 'Suicide.1')

kable(k_means_analysis_df) %>% 
  kable_styling(bootstrap_options = "responsive")
```
From above, we isolated 12 columns that were of particular interest to us. These seemed to show some sort of trend in computed means per group. Here are some explanations and interpretations of how our k-means cluster grouped the respondents:  

+ **Cluster #1**: It looks like the 34 individuals that comprise of cluster number 1 are on the younger end, given that the average age of 26 is below the 25th percentile of our overall dataset. Additionally, it appears that this group had a high average total for the ADHD questions, as well as the highest total for the MD questions. Additionally, they had the highest average for responding that they had a dependence on alcohol, and also the highest average that had attempted to commit suicide and a court order.  

+ **Cluster #2**: The 18 individuals in this cluster make up the youngest average age out of the rest of the four clusters. The individuals in this group also comprised of the largest male majority, lowest average ADHD total, lowest average dependence on alcohol, highest average dependence on THC, and second highest average in having a court order.  

+ **Cluster #3**: The 43 individuals in this cluster make up our largest group, with the oldest average age of around 48 years. Additionally, it has a majority of male respondents, it had the second highest average dependence on alcohol, and second lowest average dependence on THC (most responded as "do not use"). This group seems to fall outside of many of the substance abuse tendencies, has the lowest average responding that they had a history of violence, as well as the lowest average of having attempted suicide.  

+ **Cluster #4**: The 39 individuals in this cluster make up the group with the second oldest average age. It has a majority of female respondents, the highest average total for the ADHD questions, the second highest average total for the MD questions, the lowest average dependence on THC (most responded as "do not use"), and the second highest average for those responding that they have attempted suicide.  

+ **Cluster #5**:  The final cluster of 41 individuals make up the group with an average age that sits right in between our other four clusters. Additionally, this group falls in between other clusters on most other averages, except nobody in this group had responded that they have a court order, and they had the highest average for responding with a history of violence.  

### Hierarchical Clustering

Hierarchical clustering, also known as hierarchical cluster analysis, is an algorithm that groups similar objects into groups called clusters. The endpoint is a set of clusters, where each cluster is distinct from each other cluster, and the objects within each cluster are broadly similar to each other.

There are 5 main methods to measure the distance between clusters, referred as linkage methods:

+ **Single linkage**: computes the minimum distance between clusters before merging them.  
+ **Complete linkage**: computes the maximum distance between clusters before merging them.  
+ **Average linkage**: computes the average distance between clusters before merging them.  
+ **Centroid linkage**: calculates centroids for both clusters, then computes the distance between the two before merging them.  
+ **Ward’s (minimum variance) criterion**: minimizes the total within-cluster variance and find the pair of clusters that leads to minimum increase in total within-cluster variance after merging.  

We can apply the hierarchical clustering with the complete linkage criterion thanks to the hclust() function with the argument method = "complete" and method = "ward.D2":

```{r}
d <- dist(df_dummy, method = "euclidean")
hclust1 <- hclust(d, method = "complete")
```


```{r}

plot(hclust1, hang = -1, cex = 0.4, main = "Complete linkage hierarchical clustering dendrogram")
rect.hclust(hclust1,
  k = 5, # k is used to specify the number of clusters
  border = "steelblue"
)
```


Above, we can see the visual representation of our complete linkage hierarchical clustering dendrogram, including the 5 deliniated clusters in blue. Later, we can compare this to the Ward's method hierarchical clustering dendrogram that is presented below:  

```{r}
hclust2 <- hclust(d, method = "ward.D2")
```

```{r}
plot(hclust2, hang = -1, cex = 0.4, main = "Ward's method hierarchical clustering dendrogram")
rect.hclust(hclust2,
  k = 5, # k is used to specify the number of clusters
  border = "coral"
)
```

We compare hierarchical clustering with complete linkage versus Ward’s method. The function tanglegram plots two dendrograms, side by side, with their labels connected by lines.
```{r}
dend1 <- as.dendrogram (hclust1)
dend2 <- as.dendrogram (hclust2)
```

```{r}
dend_list <- dendlist(dend1, dend2)

tanglegram(dend1, dend2,
  highlight_distinct_edges = FALSE, # Turn-off dashed lines
  common_subtrees_color_lines = FALSE, # Turn-off line colors
  common_subtrees_color_branches = TRUE, # Color common branches 
  main = paste("entanglement =", round(entanglement(dend_list), 2))
  )
```
\br

As we can see above, the entanglement value of 0.94 is very close to 1, meaning that there isn't a lot of alignment between the two dendrograms. Additionally, when we use the `cor_cophenetic()` and `cor_bakers_gamma()` functions, which measure the Cophenetic and Baker correlation coefficient's respectively, we can see that both of these values fall between 0.6 and 0.7. This indicates that there is some correlation between the two dendrograms, but they aren't *very* correlated with one another.

```{r}
paste0('Cophenetic correlation coefficient: ', cor_cophenetic(dend_list))
paste0('Baker correlation coefficient: ', cor_bakers_gamma(dend_list))
```

Given our hierarchical clustering techniques, we decided to try and visualize characteristics across each of our five clusters for our complete linkage HC model. To do this, we decided to create a heatmap which shows the percent of each factor level (i.e. every value of 1) in the absolute count of cluster members, to determine which factors seemed to be found the most among members of each cluster.

```{r, fig.height=20, fig.width=10}
require(reshape2)
# Time for the heatmap
# the 1st step here is to have 1 variable per row
# factors have to be converted to characters in order not to be dropped
clust.num <- cutree(hclust1, k = 5)
df.cl <- cbind(df_dummy, clust.num)
df.cl <- df.cl %>% mutate(rownum = row_number())
df.long <- melt(data.frame(lapply(df.cl, as.character), stringsAsFactors=FALSE), 
                  id = c("rownum", "clust.num"), factorsAsStrings=T)
df.long.q <- df.long %>%
  group_by(clust.num, variable, value) %>%
  mutate(count = n_distinct(rownum)) %>%
  distinct(clust.num, variable, value, count)

#heatmap.c will be suitable in case you want to go for absolute counts - but it doesn't tell much to my taste
heatmap.c <- ggplot(df.long.q, aes(x = clust.num, y = variable, ordered = T)) +

  geom_tile(aes(fill = count))+
  scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4")


# heatmap.c

# calculating the percent of each factor level in the absolute count of cluster members
df.long.p <- df.long.q %>%
  group_by(clust.num, variable) %>%
  mutate(perc = count / sum(count)) %>%
  arrange(clust.num)

heatmap.p <- ggplot(df.long.p, aes(x = clust.num, y = variable, ordered = T)) +

geom_tile(aes(fill = perc), alpha = 0.85)+
  labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) +
  geom_hline(yintercept = 3.5) +
  geom_hline(yintercept = 10.5) +
  geom_hline(yintercept = 13.5) +
  geom_hline(yintercept = 17.5) +
  geom_hline(yintercept = 21.5) +
  scale_fill_gradient2(low = "#E8D5B5", mid = "#7AB4C0", high = "#3E3496")
heatmap.p
```
[TODO: Zach Comment, I did my best with the interpretation of the viz above, but definitely feel free to edit as you see fit. We can also strip this down a bit based on variable importance!]

From our above visualization, we can see a few distinct trends:  

+ **Cluster 1**: we can see here that most members of in this cluster use cocaine, THC, and alcohol, have an education level at 11th grade (indicating they do not have a high school diploma), and take more than one psychotropic medication.  

+ **Cluster 2**: we can see here that most of the members of this cluster have an education level at the college level (13 or above), do not use alcohol, and agreed consistently with a response of "rarely" for many of the ADHD questions. With further metadata on the survey questions, we'd be able to identify even more trends based on these questions.    

+ **Cluster 3**: we can see here that most members of this cluster had more than one non-substance-related disorder and answered with "sometimes" or "often" more frequently on ADHD questions.  

+ **Cluster 4**:  we can see here that most members of this cluster had experienced physical abuse, or a combination of physical and emotional abuse, answered "very often" on a lot of the ADHD questions, were users of THC and alcohol, and had a low education level (around 10th grade).  

+ **Cluster 5**: we can see here that most members of this cluster also answered "very often" on a lot of the ADHD questions and were less likely to use sedative hypnotics and psychiatric medications than other clusters.  


### Identify "Profiles"

[EDA of Segments - use variable importance to see which features (factor and value) were most important, then see if there are clear groupings]

```{r}

```



***

## **Part 2: Principal Component Analysis (PCA)**

***

Let’s explore using Principal Component Analysis on this dataset.  You will note that there are different types of questions in the dataset: **columns E-W**: ADHD self-report; **column X–AM**: mood disorders questionnaire, **column AN-AS**: Individual Substance Misuse; etc. Please reason through your work as you decide on which sets of variables you want to use to conduct Principal Component Analysis. *(60)*

Principal Component Analysis (PCA) is an unsupervised, non-parametric statistical technique primarily used for dimensionality reduction in machine learning. It is a useful technique for exploratory data analysis, allowing us to better visualize the variation present in a dataset with many variables.
```{r}
df_dummy.pca <- prcomp(df_dummy, center = TRUE,scale. = TRUE)

summary(df_dummy.pca)
```



The scale = 0 argument to biplot ensures that the arrows are scaled to represent the loadings; other values for scale give slightly different biplots with different interpretations.

```{r fig.height=8, fig.width=12}
biplot(df_dummy.pca, scale = 0)
```


Visualize eigenvalues (scree plot). Show the percentage of variances explained by each principal component.
```{r}
fviz_eig(df_dummy.pca)
```

Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.
```{r}
fviz_pca_var(df_dummy.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
```



```{r}
#compute standard deviation of each principal component
std_dev <- df_dummy.pca$sdev

#compute variance
pr_var <- std_dev^2


prop_varex <- pr_var/sum(pr_var)

round(prop_varex[1:10], 2)
```
The first principal component in our example therefore explains 12% of the variability, and the second principal component explains 6%. Together, the first ten principal components explain 39% of the variability. And we proceed to plot the PVE and cumulative PVE to provide us our scree plots as we did earlier.



```{r}
#scree plot
plot(prop_varex, xlab = "Principal Component",
             ylab = "Proportion of Variance Explained",
             type = "b")

#cumulative scree plot
plot(cumsum(prop_varex), xlab = "Principal Component",
              ylab = "Cumulative Proportion of Variance Explained",
              type = "b")
```


***

## **Part 3: Support Vector Machine**

***

Assume you are modeling whether a patient attempted suicide (column AX). Please use support vector machine to model this. You might want to consider reducing the number of variables or somehow use extracted information from the variables. This can be a really fun modeling task! *(80)*



To test the accuracy , we first separate the data into training and test dataset.
```{r}
df2<-data.frame(df)
index<-createDataPartition(df2$Suicide,p=0.8,list = FALSE)
df_train<-df2[index,]
df_test<-df2[-index,]

```


The data has 53 variables and we can use random Forests to reduce the number of variables.Random Forests are often used for feature selection in a data science workflow. The tree-based strategies used by random forests naturally ranks by how well they improve the purity of the node. This mean decrease in impurity over all trees (called Gini impurity)and we can use it to determine the final importance of the variable.

```{r}
# Use random Forest to select features
rf<-randomForest(Suicide~.,data=df_train)

importance(rf)
varImpPlot(rf,type=2)
```
Variable Abuse has the highest MeanDecrease Gini, 4.7517859 and it is the most important variables. We plan to select the top 10 most important variables to fit our SVM model. The variables we choose are Abuse,Education,ADHD.Q1,Alcohol,ADHD.Q16,
ADHD.Total,ADHD.Q18,ADHD.Total,ADHD.Q9 and ADHD.Q2.



```{r}
set.seed(123)
# select top 10 variables from Importance Table
df.svm=svm(Suicide~Abuse+Education+ADHD.Q1+Alcohol+ADHD.Q16+ADHD.Total+ADHD.Q18+ADHD.Total+ADHD.Q9+ADHD.Q2,data=df_train, kernel="radial", cost = 10, scale = FALSE)
summary(df.svm)
```
We use Radial kernel in our support vector classification and the number of support vectors is 90.

Then we can test the accurancy using our test data.
```{r}
svmPre1<-predict(df.svm,df_test)
svm1<-confusionMatrix(svmPre1,df_test$Suicide)
svm1
```

The accuracy is 0.6471.  Considering we only use 10 variables, the test result is not bad. We can tune the Model by trying different parameters. 


```{r}
svm.tune <- tune(e1071::svm, Suicide~Abuse+Education+ADHD.Q1+Alcohol+ADHD.Q16+ADHD.Total+ADHD.Q18+ADHD.Total+ADHD.Q9+ADHD.Q2, 
                 data = df_train,
                 ranges=list(cost=c(0.001,0.01,0.1,1,5,10,100),
                 kernel=c("linear", "polynomial", "radial"),
                 gamma=c(0.5,1,2,3,4)))


summary(svm.tune)
bestmod=svm.tune$best.model
bestmod
```
Tune() perform ten-fold cross-validation by default. To test the best kernel, we use linear, polynomial and radial in the tuning model and found out that the best model use Linear kernel with cost of 5. From the table, we can see that the lowest error rate is 0.2490476.

We can use confusion Matrix to check the table and accuracy. 

```{r}
svmPre2<-predict(bestmod,df_test)
svm2<-confusionMatrix(svmPre2,df_test$Suicide)
svm2
```
After we tune the model, the accuracy rate increase to 0.7059, which is much better than the previous one without turning. 
