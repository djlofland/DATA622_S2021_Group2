---
title: "Data 622 - Homework #4 (Group 2)"
author: "Mengqin Cai, Zhi Ying Chen, Donny Lofland, Zach Alexander"
date: "5/7/2021"
output: 
  html_document:
    theme: cerulean
    highlight: pygments
    css: ./lab.css
    toc: true
    toc_float: true
    code_folding: hide
  pdf_document:
    extra_dependencies: ["geometry", "multicol", "multirow", "xcolor"]
---

Source Code: [https://github.com/djlofland/DATA622_S2021_Group2/tree/master/Homework4](https://github.com/djlofland/DATA622_S2021_Group2/tree/master/Homework4)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r, include=FALSE}
library(readxl)           # Y Read Excel Data

require(naniar)
library(skimr)
require(VIM)
library(imputeTS)

library(doParallel)   # Leverage multiple cores for ML

require(MASS)
require(gbm)
require(xgboost)
library(forecast)
require(rpart)
require(rpart.plot)
require(randomForest)
require(caret)
require(pROC)

library(tidyverse)        # TIDY packages
library(dplyr)   # dplyr has to be loaded before tidyr
library(tidyr)

require(ggplot2)
require(GGally)
require(tidyr)
require(Amelia)
require(psych)
require(class)
require(tree)
require(knitr)
require(kableExtra)
require(mice)

library(corrplot)
library(RColorBrewer)
library(broom)
library(cluster)
library(factoextra)
library(NbClust)
library(dendextend)

library(e1071)
```


For this assignment, we will be working with a very interesting mental health dataset from a real-life research project. All identifying information, of course, has been removed. The attached spreadsheet has the data (the tab name “Data”). The data dictionary is given in the second tab. You can get as creative as you want. The assignment is designed to really get you to think about how you could use different methods.

***

## **Load Data & EDA**

***

### Load Data

We start by loading the Excel dataset provided into a dataframe.

```{r, echo=FALSE}
# Load data
df <- read_excel('data/ADHD_data.xlsx')
```


#### Data Sample

Next, we can take a quick look at the dataframe features. By highlighting the data dictionary below, and printing the first few rows, we can start to establish some context around the data that has been collected from the survey.

```{r}
# Display first few rows for inspection
kable(head(df)) %>% 
  kable_styling(bootstrap_options = "basic")
```

#### Data Dictionary

* **Initial** *Respondents initial*:  we will drop this column
* **Age** *Age*:  0 ... 69
* **Sex** *Sex*:  Male-1, Female-2
* **Race** *Race*:  White-1, African American-2, Hispanic-3, Asian-4, Native American-5, Other or missing data -6
* **ADHD Q(n)** *ADHD self-report scale*: Never-0, rarely-1, sometimes-2, often-3, very often-4
* **ADHD Total** *ADHD self-report Total*: Sum of ADHD question scores
* **MD Q(n)** *Mood disorder questions*: No-0, yes-1; question 3: no problem-0, minor-1, moderate-2, serious-3
* **MD TOTAL** *MD self-report Total*: Sum of MD question scores
* **Alcohol**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **THC**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Cocaine**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Stimulants**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Sedative-hypnotics**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Opioids**  *Individual substances misuse*:  no use-0, use-1, abuse-2, dependence-3
* **Court order** *Court Order*:  No-0, Yes-1
* **Education** *Education*: 1-12 grade, 13+ college
* **Hx of Violence** *History of Violence*: No-0, Yes-1
* **Disorderly Conduct** *Disorderly Conduct*: No-0, Yes-1
* **Suicide** *Suicide attempt*: No-0, Yes-1
* **Abuse** *Abuse Hx*: No-0, Physical (P)-1, Sexual (S)-2, Emotional (E)-3, P&S-4, P&E-5, S&E-6, P&S&E-7
* **Non-subst Dx** *Non-substance-related Dx*: 0 – none; 1 – one; 2 – More than one
* **Subst Dx** *Substance-related Dx*: 0 – none; 1 – one Substance-related; 2 – two; 3 – three or more
* **Psych meds.** *Psychiatric Meds*: 0 – none; 1 – one psychotropic med; 2 – more than one psychotropic med


#### Data Frame summary

After reading in the dataframe and identifying the data dictionary that explains the values for our features, our next step is to do some exploratory analysis. We can initially run the `skim()` function to find important generalized information about the dataset.

```{r}
# Show df summary deatils
skim(df)
```

We can see above that the dataset consists of 175 observations and 54 different features. A few of the features have quite a few missing values, including the `Psych meds.` feature (with 118 missing values), as well as `Subst Dx` and `Non-subst Dx`, which have 23 and 22 missing values, respectively. These questions, when looking at the data summary above, correspond to medication questions that are specific to a particular population -- for instance, when sampling the general population for a survey, likely a smaller percentage (and not a majority) will be on psychiatric medication, or be taking medication for substance use/non-substance use related causes. Therefore, many of these missing values make sense, but will be important to keep in mind when we start our clustering techniques.  

Another interesting component of the `skim()` function is to be able to take a quick look at the distribution of responses for each feature. From the `Education` distribution, we can see that the median education level was a high school diploma (12th grade). Also, there seemed to be slightly more males than females that responded to the survey, and the median age was around 42 years. Additionally, we can see that a majority of respondents to many of the substance-use questions, such as `Cocaine`, `THC` and `Alcohol` tended to answer as either "no use", or "dependence", with not much gray area in between. Finally, a large majority of respondents self-identified their race as White.  


### Missing Values

As we saw in our data summary, we have some missing values.  Lets explore this a little further to see if any important patterns stand out.  

```{r}
# Use nanair package to plot missing value patterns
gg_miss_upset(df)
```

The missing data only appears in a few of our features: `Suicide`, `Abuse`, `Non-subst Dx`, `Subst Dx`, and `Psych meds.`.

We can use kNN imputation to help replace many of the missing values. With the KNN method, a categorical missing value is imputed by looking at other records with similar features. Once k similar records are found, they are used to infer the missing value. Note that imputing can inherently introduce bias and there is a trade-off between loosing information versus bias when trying to fill in holes.  

We also see that for each respondent, we have their initial.  This won't be useful for our purposes (note there are also duplicates where multiple people had the same initials).

```{r}

## Use kNN to impute the data
df<-kNN(df)%>%
  select(Age:'Psych meds.')

```

Looking at our dataset, we see that missing values are no longer an issue; however, we still have some additional cleanup to perform on our dataset below before we proceed with kNN modeling.   

```{r}
# Display data from summary
skim(df)
```

#### Fix Datatypes

We know that most of our features are either factors or ordinal factors.  Let's recode from `float` to `factor` to ensure our models don't incorrectly treat them as continuous.  Note that we'll leave `Age` as continuous even though it's technically an ordinal factor.  Also, for simplicity, `boolean` features (only 0 or 1) can be left as `integer`.  Looking ahead, factors are going to lead to a large number of features when we dummy code in preparation for modeling.  Dummy encoding leads to separate columns for each value.  High dimensions can lead to problems.Fortunately, we don't have that many features and values, so we aren't starting with an excessive number of columns.  That said, we will likely need to either reduce dimensions thorough PCA or different recoding approaches.  

```{r}
# We'll leave age as an integer
df$Age                  <- as.integer(df$Age)

# Misc columns (note: some columns are ordinal, others are not)
df$Sex                  <- factor(df$Sex)
df$Race                 <- factor(df$Race)
df$Alcohol              <- factor(df$Alcohol)
df$THC                  <- factor(df$THC)
df$Cocaine              <- factor(df$Cocaine)
df$Stimulants           <- factor(df$Stimulants)
df$`Sedative-hypnotics` <- factor(df$`Sedative-hypnotics`)
df$Opioids              <- factor(df$Opioids)

df$Education            <- factor(df$Education)

df$`Court order`        <- factor(df$`Court order`)
df$`Hx of Violence`     <- factor(df$`Hx of Violence`)
df$`Disorderly Conduct` <- factor(df$`Disorderly Conduct`)
df$Suicide              <- factor(df$Suicide)

df$Abuse                <- factor(df$Abuse)

df$`Non-subst Dx`       <- factor(df$`Non-subst Dx`)
df$`Subst Dx`           <- factor(df$`Subst Dx`)
df$`Psych meds.`        <- factor(df$`Psych meds.`)

# Quick trick to fix all columns matching name pattern
df <- df %>%
  mutate(across(contains('ADHD'), factor)) %>%
  mutate(across(contains('MD Q'), factor))

# Back these out since they are totals (sum), not factor
df$`ADHD Total`         <- as.integer(df$`ADHD Total`)
df$`MD TOTAL`           <- as.integer(df$`MD TOTAL`)
```

### Feature Plots

For the continuous variables, we can examine the distributions, broken out by the target variable, `Sex`.  


```{r, fig.height = 6, fig.width = 6}

df_plot = df %>% mutate(Sex = ifelse(Sex == 1, "Male", "Female"))

par(mfrow=c(2,3))
par(oma=c(0,0,6,0))


tbl1 <- table(df_plot$Sex, df_plot$Alcohol)
barplot(tbl1, main="Alcohol use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)), legend=TRUE)

tbl2 <- table(df_plot$Sex, df_plot$Cocaine)
barplot(tbl2, main="Cocain use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl3 <- table(df_plot$Sex, df_plot$THC)
barplot(tbl3, main="THC use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl4 <- table(df_plot$Sex, df_plot$Stimulants)
barplot(tbl4, main="Stimulant use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl5 <- table(df_plot$Sex, df_plot$`Sedative-hypnotics`)
barplot(tbl5, main="Sedative-hypnotic use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl6 <- table(df_plot$Sex, df_plot$Opioids)
barplot(tbl6, main="Opioid use",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))


title("(0 = No use, 1 = Use, 2 = Abuse, 3 = Dependence)" , outer=TRUE)
par(oma=c(1,0,3,0))
title("SUBSTANCE USE RESPONSES BY SEX" , outer=TRUE)


```
```{r, fig.height=3, fig.width=6}

myColors <- ifelse(df_plot$Sex=="Male" , "thistle3", "cornflowerblue")

par(mfrow=c(1,2))
boxplot(df_plot$`ADHD Total`~df_plot$Sex, xlab="", ylab = "ADHD Total", main="ADHD Totals by Sex", col=myColors)
boxplot(df_plot$`MD TOTAL`~df_plot$Sex, xlab="", ylab = "MD Total", main="MD Totals by Sex", col=myColors)
```

```{r, fig.height=8, fig.width=6}
par(mfrow=c(2,2))
par(oma=c(0,0,6,0))

tbl7 <- table(df_plot$Sex, df_plot$`Court order`)
barplot(tbl7, main="Court order",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl8 <- table(df_plot$Sex, df_plot$`Hx of Violence`)
barplot(tbl8, main="History of violence",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl9 <- table(df_plot$Sex, df_plot$`Disorderly Conduct`)
barplot(tbl9, main="Disorderly conduct",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)))

tbl11 <- table(df_plot$Sex, df_plot$Suicide)
barplot(tbl11, main="Suicide",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)), legend=TRUE)


title("(0 = No, 1 = Yes)" , outer=TRUE)
par(oma=c(1,0,3,0))
title("MENTAL HEALTH AND JUSTICE INVOLVEMENT BY SEX" , outer=TRUE)
```


```{r, fig.height=6, fig.width=6}

par(mfrow=c(1,1))
par(oma=c(4,0,0,0))

df_plot = df_plot %>% mutate(Abuse = ifelse(Abuse == 0, "None", 
                              ifelse(Abuse == 1, "Physical (P)", 
                              ifelse(Abuse == 2, "Sexual (S)", 
                              ifelse(Abuse == 3, "Emotional (E)",
                              ifelse(Abuse == 4, "P & S", 
                              ifelse(Abuse == 5, "P & E", 
                              ifelse(Abuse == 6, "S & E", 
                              ifelse(Abuse == 7, "P & E & S", "Unknown")))))))))

tbl10 <- table(df_plot$Sex, df_plot$Abuse)
barplot(tbl10, main="Abuse",
        col=c("thistle3", "cornflowerblue"), ylim=range(c(0, 180)), las=2, legend=TRUE)
```


When looking at these figures broken out by our target variable `Sex`, we can see a few things:  

+ Interestingly, it appears that female respondents had an ADHD total score that was trending higher than male respondents.  

+ Mood disorder totals were similar across both male and female respondents.  

+ It appears that both male and female respondents answered "No use", more frequently for substances such as stimulants, sedative-hypnotics, and opioids, than for some of the more common drugs, such as alcohol, THC, and cocaine.  

+ It also looks like males responded more frequently as having a history of violence, or disorderly conduct.  

+ Conversely, it looks like females responded slightly more frequently than males as having attempted suicide.  

+ Finally, when looking closely at the breakdown of responses to the Abuse question by sex, we can see that females overwhelmingly responded more frequently of having experienced some form of abuse, especially sexual abuse or a combination of sexual abuse with other forms of abuse. This was noticeably more frequent than the responses by their male counterparts.



### Dummy Columns

We’ll need to dummy code our categorical variables.  This process will create new columns for each value and assign a 0 or 1.  Note that dummy encoding typically drops one value which becomes the baseline.  So if we have a categorical feature with five unique values, we will have four columns.  If all columns are 0, that represents the reference value.  This helps reduce the number of necessary columns.  With dummy columns in place, we need to remove our original variables from this dataset. 

```{r}
# dummy encode our categorical features
df_dummy <- dummyVars(~ 0 + ., drop2nd=TRUE, data = df)
df_dummy <- data.frame(predict(df_dummy, newdata = df))

# Uncomment if we want to verify the dummy df summary
#skim(df_dummy)
```

### (Near) Zero Variance

We should remove any columns with zero variance.  Note, since we are working with a sparse dataset, we do NOT want to remove **near** zero variance, just **zero** variance.

```{r}
nzv <- nearZeroVar(df_dummy, saveMetrics= TRUE)
(nzv %>% filter(zeroVar == T))

# drop columns with zero variance
nzv <- nearZeroVar(df_dummy)
df_dummy <- df_dummy[, -nzv]
```

### Transforms

`Age` is our only continuous variable.  We normalize our continuous features using a simple z-score standardization.  Although this may help our KNN model, we’ll have to be careful about interpretability later on!

```{r}
# z-score scale continuous features
df[, c("Age")] <- scale(df[, c("Age")])

df_dummy[, c("Age")] <- scale(df_dummy[, c("Age")])
```

Our data set is ready for our unsupervised models.  

```{r, warning=FALSE, message=FALSE}
# quick inspect of dataframe
kable(head(df_dummy)) %>% 
  kable_styling(bootstrap_options = "basic")
```


***

## **Part 1: Cluster Patients**

***

Please use a clustering method to find clusters of patients here.  Whether you choose to use k-means clustering or hierarchical clustering is up to you as long as you reason through your work. Can you come up with creative names for the profiles you found? *(60)*

### K-Means

Now that our data has been tidy'd and is ready to be subjected to a few unsupervised learning techniques, we'll first start with a k-means approach. The k-means algorithm works via the following steps:  

+ First, a certain number of clusters (k) is designated, and the algorithm obtains all observations and creates k random unnamed/new observations that serve as initial "centroids".  

+ These centroids are then used to compute the Euclidean distance between the centroid and the surrounding observations. For each observation, the nearest centroid is used to classify the observation, and will essentially assign a category.  

+ Then, the algorithm takes the average of all of the points in each category and recomputes the centroid based on this average. The algorithm then runs again using these new centroids.  

+ The process ends when there is no change in centroid position between one run of the clustering algorithm and another.  

For our dataset, we'll essentially subject our k-means algorithm directly to our dataset. However, for a k-means approach, you'll first have to assign the number of final clusters you'd like to classify your data into. This can be a difficult task, thus we will outline this process below.

#### Determine Segments

We'll need to identify the appropriate number for `k`. `k` represents the number of clusters we will group rows into.  Three common techniques are: Elbow, Silhouette, Gap statistic, and NBClust().  For simplicity, we will uyse the Elbow approach.  

```{r}
# Elbow method
fviz_nbclust(df_dummy, kmeans, method = "wss") +
  geom_vline(xintercept = 5, linetype = 2) + # add line for better visualization
  labs(subtitle = "Elbow method") # add subtitle
```

We can see above, that it is approximately 5. More clusters do not improve within segment variability.  Therefore, we’ll perform our initial K-Means model with $k=5$.

#### Build Model

```{r}
set.seed(42)
km_res <- kmeans(df_dummy, centers = 5, nstart = 20)

summary(km_res)

sil <- silhouette(km_res$cluster, dist(df_dummy))
fviz_silhouette(sil)

```

After running our `kmeans()` function, we can take a look at the final 5 clusters that were created by our algorithm:  
As a reminder, the interpretation of the silhouette coefficient is as follows:

* $> 0$, means that the observation is well grouped. The closer the coefficient is to 1, the better the observation is grouped.

* $< 0$, means that the observation has been placed in the wrong cluster.

* $= 0$, means that the observation is between 5 clusters.

The silhouette plot above and the average silhouette coefficient help to determine whether your clustering is good or not. If a large majority of the silhouette coefficients are positive, it indicates that the observations are placed in the correct group. This silhouette plot can therefore be used in the choice of the optimal number of classes.

It is also possible to plot clusters by using the fviz_cluster() function. Note that a principal component analysis is performed to represent the variables in a 5 dimensions plane.

```{r}
fviz_cluster(km_res, df_dummy, ellipse.type = "norm")
```

To provide some context around the clusters that were generated by our algorithm, we decided to isolate the 5 clusters we created, and subjected them to our `df_dummy` dataset, grouping and computing the means for each one of our features, to see if any noticeable trends start to arise. 

```{r}
k_means_analysis_df <- df_dummy %>%
  mutate(Cluster = km_res$cluster) %>%
  group_by(Cluster) %>%
  summarise_all("mean")
```

```{r}
k_means_analysis_df <- k_means_analysis_df %>% select('Cluster', 'Age', 'Sex.1', 'X.ADHD.Total.', 'X.MD.TOTAL.', 'Alcohol.0', 'Alcohol.3', 'THC.0', 'THC.3', 'X.Court.order.1', 'X.Hx.of.Violence.1', 'Suicide.1')

kable(k_means_analysis_df) %>% 
  kable_styling(bootstrap_options = "responsive")
```
From above, we isolated 12 columns that were of particular interest to us. These seemed to show some sort of trend in computed means per group. Here are some explanations and interpretations of how our k-means cluster grouped the respondents:  

+ **Cluster #1**: It looks like the 34 individuals that comprise of cluster number 1 are on the younger end, given that the average age of 26 is below the 25th percentile of our overall dataset. Additionally, it appears that this group had a high average total for the ADHD questions, as well as the highest total for the MD questions. Additionally, they had the highest average for responding that they had a dependence on alcohol, and also the highest average that had attempted to commit suicide and a court order.  

+ **Cluster #2**: The 18 individuals in this cluster make up the youngest average age out of the rest of the four clusters. The individuals in this group also comprised of the largest male majority, lowest average ADHD total, lowest average dependence on alcohol, highest average dependence on THC, and second highest average in having a court order.  

+ **Cluster #3**: The 43 individuals in this cluster make up our largest group, with the oldest average age of around 48 years. Additionally, it has a majority of male respondents, it had the second highest average dependence on alcohol, and second lowest average dependence on THC (most responded as "do not use"). This group seems to fall outside of many of the substance abuse tendencies, has the lowest average responding that they had a history of violence, as well as the lowest average of having attempted suicide.  

+ **Cluster #4**: The 39 individuals in this cluster make up the group with the second oldest average age. It has a majority of female respondents, the highest average total for the ADHD questions, the second highest average total for the MD questions, the lowest average dependence on THC (most responded as "do not use"), and the second highest average for those responding that they have attempted suicide.  

+ **Cluster #5**:  The final cluster of 41 individuals make up the group with an average age that sits right in between our other four clusters. Additionally, this group falls in between other clusters on most other averages, except nobody in this group had responded that they have a court order, and they had the highest average for responding with a history of violence.  

### Hierarchical Clustering

Hierarchical clustering, also known as hierarchical cluster analysis, is an algorithm that groups similar objects into groups called clusters. The endpoint is a set of clusters, where each cluster is distinct from each other cluster, and the objects within each cluster are broadly similar to each other.

There are 5 main methods to measure the distance between clusters, referred as linkage methods:

+ **Single linkage**: computes the minimum distance between clusters before merging them.  
+ **Complete linkage**: computes the maximum distance between clusters before merging them.  
+ **Average linkage**: computes the average distance between clusters before merging them.  
+ **Centroid linkage**: calculates centroids for both clusters, then computes the distance between the two before merging them.  
+ **Ward’s (minimum variance) criterion**: minimizes the total within-cluster variance and find the pair of clusters that leads to minimum increase in total within-cluster variance after merging.  

We can apply the hierarchical clustering with the complete linkage criterion thanks to the hclust() function with the argument method = "complete" and method = "ward.D2":

```{r}
d <- dist(df_dummy, method = "euclidean")
hclust1 <- hclust(d, method = "complete")
```


```{r}

plot(hclust1, hang = -1, cex = 0.4, main = "Complete linkage hierarchical clustering dendrogram")
rect.hclust(hclust1,
  k = 5, # k is used to specify the number of clusters
  border = "steelblue"
)
```


Above, we can see the visual representation of our complete linkage hierarchical clustering dendrogram, including the 5 deliniated clusters in blue. Later, we can compare this to the Ward's method hierarchical clustering dendrogram that is presented below:  

```{r}
hclust2 <- hclust(d, method = "ward.D2")
```

```{r}
plot(hclust2, hang = -1, cex = 0.4, main = "Ward's method hierarchical clustering dendrogram")
rect.hclust(hclust2,
  k = 5, # k is used to specify the number of clusters
  border = "coral"
)
```

We compare hierarchical clustering with complete linkage versus Ward’s method. The function tanglegram plots two dendrograms, side by side, with their labels connected by lines.

```{r}
dend1 <- as.dendrogram (hclust1)
dend2 <- as.dendrogram (hclust2)
```

```{r}
dend_list <- dendlist(dend1, dend2)

tanglegram(dend1, dend2,
  highlight_distinct_edges = FALSE, # Turn-off dashed lines
  common_subtrees_color_lines = FALSE, # Turn-off line colors
  common_subtrees_color_branches = TRUE, # Color common branches 
  main = paste("entanglement =", round(entanglement(dend_list), 2))
  )
```

As we can see above, the entanglement value of 0.31 is very close closer to `0`, meaning that there is alignment between the two dendrograms. Additionally, when we use the `cor_cophenetic()` and `cor_bakers_gamma()` functions, which measure the Cophenetic and Baker correlation coefficient's respectively, we can see that both of these values fall ~0.814. This indicates that there is reasonable correlation between the two dendrograms.

```{r}
paste0('Cophenetic correlation coefficient: ', cor_cophenetic(dend_list))
paste0('Baker correlation coefficient: ', cor_bakers_gamma(dend_list))
```

Given our hierarchical clustering techniques, we visualized characteristics across each of our five clusters for our complete linkage HC model. This heatmap shows the percent of each factor level (i.e. every value of 1) in the absolute count of cluster members.

```{r, fig.height=20, fig.width=10}
require(reshape2)
# Time for the heatmap
# the 1st step here is to have 1 variable per row
# factors have to be converted to characters in order not to be dropped
clust.num <- cutree(hclust1, k = 5)
df.cl <- cbind(df_dummy, clust.num)
df.cl <- df.cl %>% mutate(rownum = row_number())
df.long <- melt(data.frame(lapply(df.cl, as.character), stringsAsFactors=FALSE), 
                  id = c("rownum", "clust.num"), factorsAsStrings=T)
df.long.q <- df.long %>%
  group_by(clust.num, variable, value) %>%
  mutate(count = n_distinct(rownum)) %>%
  distinct(clust.num, variable, value, count)

heatmap.c <- ggplot(df.long.q, aes(x = clust.num, y = variable, ordered = T)) +
  geom_tile(aes(fill = count))+
  scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4")

# calculating the percent of each factor level in the absolute count of cluster members
df.long.p <- df.long.q %>%
  group_by(clust.num, variable) %>%
  mutate(perc = count / sum(count)) %>%
  arrange(clust.num)

heatmap.p <- ggplot(df.long.p, aes(x = clust.num, y = variable, ordered = T)) +

geom_tile(aes(fill = perc), alpha = 0.85)+
  labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) +
  geom_hline(yintercept = 3.5) +
  geom_hline(yintercept = 10.5) +
  geom_hline(yintercept = 13.5) +
  geom_hline(yintercept = 17.5) +
  geom_hline(yintercept = 21.5) +
  scale_fill_gradient2(low = "#E8D5B5", mid = "#7AB4C0", high = "#3E3496")
heatmap.p
```


### Identify "Profiles"

From our above visualization, we can see a few distinct trends:  

+ **Cluster 1**: we can see here that most members of in this cluster use cocaine, THC, and alcohol, have an education level at 11th grade (indicating they do not have a high school diploma), and take more than one psychotropic medication.

+ **Cluster 2**: we can see here that most of the members of this cluster have an education level at the college level (13 or above), do not use alcohol, and agreed consistently with a response of "rarely" for many of the ADHD questions. With further metadata on the survey questions, we'd be able to identify even more trends based on these questions.    

+ **Cluster 3**: we can see here that most members of this cluster had more than one non-substance-related disorder and answered with "sometimes" or "often" more frequently on ADHD questions.  

+ **Cluster 4**:  we can see here that most members of this cluster had experienced physical abuse, or a combination of physical and emotional abuse, answered "very often" on a lot of the ADHD questions, were users of THC and alcohol, and had a low education level (around 10th grade).  

+ **Cluster 5**: we can see here that most members of this cluster also answered "very often" on a lot of the ADHD questions and were less likely to use sedative hypnotics and psychiatric medications than other clusters.  

***

## **Part 2: Principal Component Analysis (PCA)**

***

Let’s explore using Principal Component Analysis on this dataset.  You will note that there are different types of questions in the dataset: **columns E-W**: ADHD self-report; **column X–AM**: mood disorders questionnaire, **column AN-AS**: Individual Substance Misuse; etc. Please reason through your work as you decide on which sets of variables you want to use to conduct Principal Component Analysis. *(60)*

Principal Component Analysis (PCA) is an unsupervised, non-parametric statistical technique primarily used for dimensionality reduction in machine learning. It is a useful technique for exploratory data analysis, allowing us to better visualize the variation present in a dataset with many variables. For our particular use case here, it appears that many of the questionnaire variables fall on likert scales, which when prepared for analysis are extended to dummy variables. This creates many additional features and can make analysis more difficult due to an increased number of dimensions. Therefore, utilizing PCA to reduce the number of dimensions on our entired dataset and measure the amount of variance explained is beneficial. In order to do this, we'll use the `prcomp()` function:  

```{r}
df_dummy.pca <- prcomp(df_dummy, center = TRUE,scale. = TRUE)

summary(df_dummy.pca)
```

The scale = 0 argument to biplot ensures that the arrows are scaled to represent the loadings; other values for scale give slightly different biplots with different interpretations.

```{r fig.height=8, fig.width=12}
biplot(df_dummy.pca, scale = 0, cex=0.5)
```


From the biplot above, it's difficult to tell much given the very large number of features. However, from our PCA analysis, we can also take a look at the eigenvalues that were generated by using a scree plot. The plot below shows the percentage of variance explained by each principal component.

```{r}
fviz_eig(df_dummy.pca)
```
```{r}
#compute standard deviation of each principal component
std_dev <- df_dummy.pca$sdev

#compute variance
pr_var <- std_dev^2


prop_varex <- pr_var/sum(pr_var)

round(prop_varex[1:10], 2)
```

The first principal component in our example therefore explains 12% of the variability, and the second principal component explains 6%. Together, the first ten principal components explain 39% of the variability. And we proceed to plot the PVE and cumulative PVE to provide us our scree plots as we did earlier.  

```{r}
#scree plot
plot(prop_varex, xlab = "Principal Component",
             ylab = "Proportion of Variance Explained",
             type = "b")

#cumulative scree plot
plot(cumsum(prop_varex), xlab = "Principal Component",
              ylab = "Cumulative Proportion of Variance Explained",
              type = "b")
```

As we can see above in our plots of the PVE and the cumultative PVE, the first few principal components account for a much larger proportion of the variance explained than the remaining 150+ principal components for this dataset. Additionally, the proportion of variance explained by the first principal component at 12% is double the second principal component's proportion of variance explained.  


Although running PCA on the entire dataset is helpful in some ways, certain findings from a biplot are affected by the number of variables in the overall dataset. Additionally, we are seeing from our PCA analysis that the first few principal components explain a much larger proportion of the variability than later principal compnents. Because of this, we thought it would be interesting to dive a bit deeper into which variables seem to hold the most importance in determining the first few dimensions. To do this, we'll use the `FactoMineR` and `factoextra` packages to determine the eigenvalues of each dimension, with particular interest in dimensions 1 and 2, since those are what we've plotted above and hold the highest proportion of variance explained. 

```{r, warning=FALSE, message=FALSE}
library("FactoMineR")
library("factoextra")

eig.val <- get_eigenvalue(df_dummy.pca)
eig.val
```

```{r}

res.pca <- PCA(df_dummy, scale.unit = TRUE, ncp = 5, graph = FALSE)
var <- get_pca_var(res.pca)
```

Interestingly, eigenvalues less than 1 indicate that principal components account for more variance than accounted by one of the original variables in the standardized data. Because of this, many use this as a cutoff point for which PCs should be retained. Since we see this cutoff occur at Dim = 50, anything past this dimension doesn't provide good insight into our data. Above, our scree plot cut this even further, by showing that anything past the first ten dimensions does not account for a large proportion of variance explained. Therefore, going forward, we will only focus on the first few dimensions to see if we can garner any insights.  

Since our biplot above was very crowded and difficult to interpret, we decided to look a bit deeper at the quality of representation of the variables, which is determined by taking the square cosine (cos2) and accounts for a variable's position relative to the circumference of the correlation circle (not pictured in our biplot above but can be visually seen by the length of each vector from the center/origin). After subjecting these cos2 values to a corrplot across tthe first five PCs, we can examine below:  

```{r, fig.height=28, fig.width=4}

library("corrplot")
corrplot(var$cos2, is.corr=FALSE)
```

Typically, a high cos2 value indicates a good representation of the variable on the principal component, and in our case the variable is positioned close to the circumference of the correlation circle (and farther away from the origin) -- which we can visibly see with variables such as X.ADHD.Total and X.MD.Total on the biplot. The opposite is true for variables with a low cos2 value, which tend to fall closer to the origin.  

We can also take a look at factors such as the contribution of variables on our principal components. Variables that are correlated with PC1 and PC2 are the most important in explaining the variability in the dataset. Therefore, when we conduct another correlation plot, but this time of variable contribution, we see the following:  

```{r, fig.height=28, fig.width=4}
corrplot(var$contrib, is.corr=FALSE)
```


We can also see this in a barplot below, and shows the variables that have the highest contribution percentage for our first two PCs:  

```{r}
fviz_contrib(df_dummy.pca, choice = "var", axes = 1, top = 15)
fviz_contrib(df_dummy.pca, choice = "var", axes = 2, top = 15)
```

Similar to our biplot visualization and our cos2 values, we can confirm that variables such as `X.ADHD.Total` and `X.MD.Total`, as well as many other ADHD and MD questions contribute most to the variability explained in our dataset. This is important for us to take not of for future analysis, where we will be looking more closely at features that seem to provide more insight into clustering and classification. 

Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph.

```{r, warning=FALSE}
fviz_pca_var(df_dummy.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
```

***

## **Part 3: Support Vector Machine**

***

Assume you are modeling whether a patient attempted suicide (column AX). Please use support vector machine to model this. You might want to consider reducing the number of variables or somehow use extracted information from the variables. This can be a really fun modeling task! *(80)*

In order to run our SVM model correctly, our first step will be to separate the data into training and test dataset. This way, we can test the accuracy by using our holdout test set later on. We decided to perform a conventional 80/20 training to testing data split on our original dataframe.  

```{r}
set.seed(123)
df2      <- data.frame(df)
index    <- createDataPartition(df2$Suicide, p=0.8, list = FALSE)
df_train <- df2[index,]
df_test  <- df2[-index,]

```

Since the data has 53 variables, and SVM works much better on lower dimensional datasets, we'll need to perform some sort of dimensionality reduction for feature selection. To do this, we decided to use a Random Forest algorithm to reduce the number of variables. Random Forests are often used for feature selection in a data science workflow. The tree-based strategies used by random forests naturally ranks how well they improve the purity of the node. This means, that if there is a decrease in impurity over all trees (called Gini impurity) then we can use it to determine the final importance of the variable.  

Therefore, we'll run our random forest algorithm and find the importance of each one of our features.

```{r}
# Use random Forest to select features
rf<-randomForest(Suicide~., data=df_train)

importance(rf)
varImpPlot(rf,type=2)
```

As we can see from the mean decrease Gini scores above, the variable `Abuse` has the highest mean decrease Gini value, at 6.386, which means that it has the highest variable importance. To fit our initial Support Vector Machines model, we plan to select the top 10 variables with the highest mean decrease Gini value. Therefore, the variables we choose for this initial SVM fit are `Abuse`, `Education`, `ADHD.Q1`, `Alcohol`, `ADHD.Q16`,
`ADHD.Total`, `ADHD.Q18`, `MD.TOTAL`, `ADHD.Q9`, and `ADHD.Q2`.

```{r}
# set.seed(123)

# select top 10 variables from Importance Table
df.svm=svm(Suicide~Abuse+Education+ADHD.Q1+Alcohol+ADHD.Q16+ADHD.Total+ADHD.Q18+MD.TOTAL+ADHD.Q9+ADHD.Q2,data=df_train, kernel="radial", cost = 10, scale = FALSE)
```

We use Radial kernel in our support vector classification and the number of support vectors is 90.

Then we can test the accurancy using our test data.

```{r}
svmPre1<-predict(df.svm,df_test)
svm1<-confusionMatrix(svmPre1,df_test$Suicide)
svm1
```

The accuracy is 0.7353.  Considering we only use 10 variables, the test result is not bad. We can tune the Model by trying different parameters. 

```{r}
svm.tune <- tune(e1071::svm, Suicide~Abuse+Education+ADHD.Q1+Alcohol+ADHD.Q16+ADHD.Total+ADHD.Q18+MD.TOTAL+ADHD.Q9+ADHD.Q2, 
                 data = df_train,
                 ranges=list(cost=c(0.001,0.01,0.1,1,5,10,100),
                 kernel=c("linear", "polynomial", "radial"),
                 gamma=c(0.5,1,2,3,4)))


summary(svm.tune)
bestmod=svm.tune$best.model
bestmod
```

The `tune()` function performs ten-fold cross-validation by default. To test the best kernel, we use linear, polynomial and radial in the tuning model and discovered that the best model uses a Linear kernel with a cost of 0.1. From the table, we can see that the lowest error rate is 0.2561905.

We can use confusion Matrix to check the table and accuracy. 

```{r}
svmPre2<-predict(bestmod,df_test)
svm2<-confusionMatrix(svmPre2,df_test$Suicide)
svm2
```

It appears that the tuning of our initial SVM model improved the accuracy rate slightly to 0.7941, which is better than the previous one without tuning.  

[TO DO: (Zach comment) visualization of SVM here, it looks like we can only do this in two dimensions, so we'll have to pick some that seem important (i.e. Abuse, ADHD Total, etc.)]

To visualize this further, by:

```{r}
library(e1071)


# data(cats, package="MASS")
# m1 <- svm(Sex~., data = cats)
# plot(m1, cats)

# 
# plot(bestmod, df_test, Abuse~Alcohol)
```

[TODO: Final comments about our SVM model]
