---
title: "Data 622 - Homework #3 "
author: "Mengqin Cai, Zhi Ying Chen, Donny Lofland, Grace Han, Zach Alexander"
date: "4/5/2021"
output: 
  html_document:
    df_print: paged
    toc: yes
    toc_collapsed: yes
    toc_float: yes
  md_document:
    variant: markdown_github
  pdf_document:
        extra_dependencies: ["geometry", "multicol", "multirow"]
theme: lumen
number_sections: yes
toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r,include=FALSE}
require(palmerpenguins)
require(dplyr)
require(ggplot2)
require(caret)
require(pROC)
require(GGally)
require(tidyr)
require(Amelia)
require(VIM)
require(MASS)
require(psych)
require(class)
require(tree)
require(rpart)
require(rpart.plot)
require(randomForest)
require(knitr)
require(kableExtra)
require(naniar)
require(mice)
```


***

#### **Part 1: KNN on the Penguins dataset**


***

**Please use K-nearest neighbor (KNN) algorithm to predict the species variable. Please be sure to walk through the steps you took. (40 points)**

Similar to past assignments when using the Palmer Penguins dataset, we'll first do some quick exploratory analysis to examine the different features available.  

We can see below, that there are four continuous variables: `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm` and `body_mass_g`. Additionally, there are a few categorical variables: `island`, `sex`, and `year`.  

```{r, echo=FALSE}
penguins <- data.frame(penguins)

kable(head(penguins)) %>% kable_styling(bootstrap_options = "basic")
```

For the continuous variables, we can examine the distributions, broken out by the target variable, `species`:  

```{r, message=FALSE, warning=FALSE, fig.width=12, fig.height=10, echo=FALSE}
penguins %>%
  dplyr::select(species, body_mass_g, bill_length_mm, bill_depth_mm, flipper_length_mm) %>%
  ggpairs(aes(color = species))
```

By separating our distributions by our target variable, `species`, we can see that many of the feature interactions show clustering between Adelie and Chinstrap penguins (red and green), while Gentoo penguins tend to contrast the other two species for most interactions. This is also confirmed by most of the single-variable distributions split out by species in the plots below. With the exception of the distribution of `bill_length_mm`, distributions for `body_mass_g`, `bill_depth_mm`, and `flipper_length_mm` all show there to be overlapping distributions between Adelie and Chinstrap penguin species.  

Next, we'll do some data tidying to get our dataset ready for our KNN model. Since `year` reflects the date/time of recording, and is not beneficial for our machine learning algorithm, we'll remove it from our dataset:  

```{r}
penguins <- penguins %>% dplyr::select(-year)
```

Additionally, when looking at the number of missing values, we can see the following:  

```{r}
penguins %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  pivot_longer(cols = 1:7, names_to = 'columns', values_to = 'NA_count') %>%
  arrange(desc(NA_count)) %>%
  ggplot(aes(y = columns, x = NA_count)) + geom_col(fill = 'deepskyblue4') +
  geom_label(aes(label = NA_count)) +
  theme_minimal() +
  labs(title = 'Count of missing values in penguins dataset') +
  theme(plot.title = element_text(hjust = 0.5))
```
We can see that 11 individuals have at least one missing data point. Therefore, we'll drop these from our dataset as well.  

```{r}
penguins <- na.omit(penguins)
```

Now, we can take a look at a summary of data before splitting to get a sense of what still needs to be tidy'd in order to get it ready for our KNN model:  

```{r}
summary(penguins)
```
From above, we can see that we'll need to remove our `species` variable, and save it to a separate outcome variable in order to evaluate the performance of our KNN model later on. We can do this by running the following syntax:  

```{r}
species_actual <- penguins %>% dplyr::select(species)
penguins <- penguins %>% dplyr::select(-species)
```

Additionally, we can see below in the distributions of each of our continuous variables that the scales are inconsistent across features. For better model performance, we'll want to standardize each of our features.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
penguins %>%
  dplyr::select(body_mass_g, bill_length_mm, bill_depth_mm, flipper_length_mm) %>%
  ggpairs()
```
In order to do this, we'll administer a z-score standardization to fix our scaling, which will ultimately help with our clustering.

```{r}
penguins[, c("bill_length_mm","bill_depth_mm", "flipper_length_mm", "body_mass_g")] <- scale(penguins[, c("bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g")])
```

As you can see below, after the z-score standardization, the scaling on the x and y axis is a lot more consistent across our features.
```{r, message=FALSE, warning=FALSE}
penguins %>%
  dplyr::select(body_mass_g, bill_length_mm, bill_depth_mm, flipper_length_mm) %>%
  ggpairs()
```
Although this may help with our KNN model, we'll have to be careful about interpretability later on! Finally, we'll want to dummy code our `island` and `sex` variables, since they are categorical, we'll need to convert them to 1s and 0s:  

```{r}
island_dcode <- as.data.frame(dummy.code(penguins$island))
penguins <- cbind(penguins, island_dcode)
```

We'll also want to remove our original `island` variable from this dataset, since we created our dummy variables:  

```{r}
penguins <- penguins %>% dplyr::select(-island)
```

The same process will then be applied to the `sex` variable:  

```{r}
penguins$sex <- dummy.code(penguins$sex)
```

Finally, after a fair amount of data tidying and investigation, our dataset is ready for our KNN model. We can take a quick look at the updated version of our dataset:  

```{r, warning=FALSE, message=FALSE}
kable(head(penguins)) %>% kable_styling(bootstrap_options = "basic")
```
***

***Splitting into training and testing datasets***  


**Note from Zach**: I decided to run these functions higher up in the tidying section, but let me know if you'd prefer to adjust back to your code below!

```{r}
# aggr(penguins,bars=T, numbers=T, sortVars=T)
# penguins<-kNN(penguins)
# penguins<-subset(penguins,select=species:sex)
# missmap(penguins)
```

```{r}
# levels(penguins$species) <- c("Adelie", "Chinstrap", "Gentoo")
# penguins$species<-as.numeric(penguins$species)
# 
# levels(penguins$island) <- c("Biscoe", "Dream", "Torgersen")
# penguins$island<-as.numeric(penguins$island)
# 
# levels(penguins$sex) <- c("female", "male")
# penguins$sex<-as.numeric(penguins$sex)
```


```{r}
# normalize <- function(x) {
# return ((x - min(x)) / (max(x) - min(x))) }
# head(penguins)
# penguins_Trans<- as.data.frame(lapply(penguins[,3:6], normalize))
# penguins_Trans<-cbind(penguins[,1],penguins[,2],penguins_Trans,penguins[,7] )
# colnames(penguins_Trans)<-c("species","island","bill_length_mm","bill_depth_mm","flipper_length_mm","body_mass_g","sex")
# head(penguins_Trans)
```


With our dataset tidy'd, we were then able to split it into a training and test set.

```{r}
sample_size<-floor(0.8*nrow(penguins))

set.seed(123)
train_ind<-sample(seq_len(nrow(penguins)),size=sample_size)
train_penguins<-penguins[train_ind,]
test_penguins<-penguins[-train_ind,]
```

We'll also do the same for our `target` variable, using the same split:  

```{r}
species_actual_train <- species_actual$species[train_ind]
species_actual_test <- species_actual$species[-train_ind]
```

***

***Fitting the KNN model***  

Now, with our data split accordingly, we'll need to identify the appropriate number for k. To do this, we will first take a standard approach of calculating the square root of the number of rows in our training dataset:  

```{r}
sqrt(nrow(train_penguins))
```
We can see above, that it is roughly between 16 and 17. Therefore, we'll perform two KNN models with k=16 and k=17:

```{r}
set.seed(123) 
k16<-knn(train_penguins,test_penguins,cl=species_actual_train,k=16)
k17<-knn(train_penguins,test_penguins,cl=species_actual_train,k=17)
```
```{r}
misClassError <- mean(k16 != species_actual_test)
paste0('The number of misclassified penguins with 16 neighbors is: ', misClassError)
table(k16, species_actual_test)


misClassError <- mean(k17 != species_actual_test)
paste0('The number of misclassified penguins with 17 neighbors is: ', misClassError)
table(k17, species_actual_test)
```
From our resulting confusion matrices, that show the classified penguins from our KNN model compared to the actual species designations, we can see that both a k of 16 and a k of 17 preformed well on our test set. Essentially, the misclassification rate showed no difference with k=16 or k=17. Although this approach seemed to work quite effectively, we do need to be careful about how we'd go about using either one of these models to predict new data. With an artificially high k value, we could be underfitting the data.  

Therefore, as a final step, we can run one final KNN model using the `caret` package, where the built-in `train()` function will run KNN classification that automatically picks the optimal number of neighbors (k).  

```{r}
knn_caret <- train(train_penguins, species_actual_train, method = "knn", preProcess = c("center", "scale"))

knn_caret
```
From our output, we can see that a k value of 9 was chose as the optimal value for our model based on the Accuracy and Kappa values calculated. Since this inter-rater reliability metric of Kappa is quite important when working with unbalanced datasets such as our penguins dataset, this k value of 9 may ultimately perform better than our initial KNN models where k=16 or k=17. We can see this relationship determined by the `train` function for finding the optimal neighbors plotted below:  

```{r}
plot(knn_caret)
```

We can see that a neighbors value of 9 clearly showed the highest accuracy value.  

```{r}
knn_caret_predictions <- predict(knn_caret, newdata = test_penguins)
confusionMatrix(knn_caret_predictions, as.factor(species_actual_test))
```
In the end, with the `caret` package identifying the "optimal" k-value, we can see that all three of our KNN models performed very well on our test dataset. Although it will likely depend on the utility of the KNN model, it does appear that any of our three models could be chose to provide accurate predictions of the three penguin species.  

***

#### **Part 2: Decision Trees on loan approval dataset**


***

**Please use the attached dataset on loan approval status to predict loan approval using Decision Trees. Please be sure to conduct a thorough exploratory analysis to start thetask and walk us through your reasoning behind all the steps you are taking.**  

First, we decided to read in the loan approval dataset and take a look at its features:

```{r}
loan <- read.csv("https://raw.githubusercontent.com/DaisyCai2019/NewData/master/Loan_approval.csv")
kable(head(loan)) %>% kable_styling(bootstrap_options = "basic")
```

As we can see from a glimpse of the dataset above, the following features are available:  

+ **Loan_ID**: a unique identifier for each loan   
+ **Gender**: split into male/female  
+ **Married**: indicates whether the applicant is either married ("Yes") or not married ("No")  
+ **Dependents**: records the number of dependents to the applicant  
+ **Education**: indicates whether the applicant is a graduate or undergraduate student  
+ **Self_Employed**: indicates whether the applicant is either self employed ("Yes) or not ("No")  
+ **ApplicantIncome**: indicates the applicant's income  
+ **CoapplicantIncome**: indicates the coapplicant's income  
+ **LoanAmount**: indicates the loan amount (in thousands)
+ **Loan_Amount_Term**: indicates the loan amount term in number of months  
+ **Credit_History**: indicates whether or not the applicant's credit history meets loan guidelines (1 or 0)  
+ **Property_Area**: indicates whether the applicant's property is "urban", "semi urban" or "rural"  
+ **Loan_Status**: the target variable, indicates whether or not the applicant received the loan   

***

***Exploratory data analysis of the loan approval dataset***  

Now, we can run some exploratory data analysis to get a better sense of how to tidy and interpret these features. Here's an initial summary of the dataset:  
```{r}
summary(loan)
```
We can see that there are a fair amount of things we'll need to do to clean the dataset before being able to run our decision tree algorithm. First, we can see that there quite a few missing values (NAs) in our `LoanAmount`, `Loan_Amount_Term` and `Credit_History` features. Also, we noticed that there were a lot of blank values, which needed to be recoded to NAs. Therefore, we used the `naniar` package below to handle this:  

```{r}
loan <- loan %>% replace_with_na_all(condition = ~. == "")
```


```{r}
loan %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  pivot_longer(cols = 1:13, names_to = 'columns', values_to = 'NA_count') %>%
  arrange(desc(NA_count)) %>%
  ggplot(aes(y = columns, x = NA_count)) + geom_col(fill = 'deepskyblue4') +
  geom_label(aes(label = NA_count)) +
  theme_minimal() +
  labs(title = 'Count of missing values in penguins dataset') +
  theme(plot.title = element_text(hjust = 0.5))
```
This can be further visualized by the "Missingness Map" below:  

```{r, message=FALSE, warning=FALSE}
missmap(loan)
loan<-kNN(loan)%>%
          subset(select = Loan_ID:Loan_Status)
```

Before progressing, we thought it would be helpful to conduct some transformations on this data, as well as account for our N/As that we've discovered. To do this, we used the `factor` function on each feature:  

```{r}
loan$Loan_Status<-factor(loan$Loan_Status)


loan<-loan %>%
           mutate(Gender = factor(Gender),
                  Married = factor(Married),
                  Dependents=factor(Dependents),
                  Education=factor(Education),
                  Self_Employed=factor(Self_Employed),
                  Property_Area=factor(Property_Area),
                  Loan_Status=factor(Loan_Status))

summary(loan)
```

Next, we'll want to take a look at the distributions of the continuous features, which appear to be `ApplicantIncome`, `CoapplicantIncome`, `LoanAmount`, and `Loan_Amount_Term`:  

```{r, message=FALSE, warning=FALSE, echo=FALSE}
loan %>%
  dplyr::select(ApplicantIncome, CoapplicantIncome, LoanAmount, Loan_Amount_Term) %>%
  ggpairs()
```

We can see that `ApplicantIncome`, `CoapplicantIncome` and `LoanAmount` are highly right skewed, with long right tails. Conversely, it looks like `Loan_Amount_Term` is highly left skewed, with a long left tail.  

Additionally, we can also take a look at the categorical variables, broken out by our target variable of whether or not a loan was issued to the applicant. From the green bars below, we can see the total amount of loan approvals, relative to the red bars below documenting the loan denials. 

```{r, echo=FALSE}
par(mfrow=c(2,3))
tbl1 <- table(loan$Loan_Status, loan$Gender)
barplot(tbl1, main="Loan Status by Gender",
        xlab="Gender", col=c("darksalmon","darkolivegreen3"))
tbl2 <- table(loan$Loan_Status, loan$Education)
barplot(tbl2, main="Loan Status by Education",
        xlab="Education", col=c("darksalmon","darkolivegreen3"))
tbl3 <- table(loan$Loan_Status, loan$Married)
barplot(tbl3, main="Loan Status by Married",
        xlab="Married", col=c("darksalmon","darkolivegreen3"))
tbl4 <- table(loan$Loan_Status, loan$Self_Employed)
barplot(tbl4, main="Loan Status by Self Employed",
        xlab="Self_Employed", col=c("darksalmon","darkolivegreen3"))
tbl5 <- table(loan$Loan_Status, loan$Property_Area)
barplot(tbl5, main="Loan Status by Property_Area",
        xlab="Property_Area", col=c("darksalmon","darkolivegreen3"))
tbl6 <- table(loan$Loan_Status, loan$Credit_History)
barplot(tbl6, main="Loan Status by Credit_History",
        xlab="Credit_History", col=c("darksalmon","darkolivegreen3"))
```

From the categorical variable splits based on loan approval status, we can see a few interesting things:  

+ The number of loans applied for by males was significantly higher than loans applied for by females in this dataset. 

+ The same phenomenon is true for graduate students, where a much higher number of loan applications were coming from graduate students relative to undergraduate students.  

+ Whether or not the applicant was self employed or married also showed a pretty large class imbalance, where those that identified as not self employed and those that identified as married had higher proportions of applicants in this dataset than those that did not identify by those two characteristics.  

+ There was a pretty even split in the number of applicants based on property area, where someone identifying that they live in rural, semiurban, or urban settings were pretty evenly distributed.  

+ We can see that applicants that did not pass the credit history criteria were almost always likely to be denied a loan.  

These factors will be interesting to examine and discuss as we look to build our decision tree model and random forest models, since these class imbalances could affect model performance and interpretation.  

***

***Imputing our data to reconcile missing values (NAs) and adjust transformations***  

Since there were a large amount of missing values that we identified above, we can use the `mice` package to help with our imputations. This package helps in imputing missing values with plausible data values. These values are inferred from a distribution that is designed for each missing data point.  

From the mice documentation, we can determine that "mice" stands for multiple imputation by chained equations. The 'm' argument in the function indicates how many rounds of imputation we want to do. In our case, we'll do two rounds of imputation (arbitrarily). The 'method' argument indicates which of the many methods for imputations we want to use. I chose CART which stands for classification and regression trees. This method seems to work with all variables types, and will provide flexibility for us as we move forward. 

```{r, echo=FALSE, eval=FALSE}
loan_imputed <- mice(loan, m=2, maxit = 2, method = 'cart', seed = 500)
```

```{r}
loan <- complete(loan_imputed, 2)
```

Now, we can double check that this worked correctly by running syntax to find any missing values:
```{r, warning=FALSE, message=FALSE}
sapply(loan, function(x) sum(is.na(x)))
```
Fortunately, we can see that there are now no missing data points!

Next, we'll have to work through a few transformations for our highly skewed continuous data. For our `LoanAmount` feature, we can conduct a log transformation:  

```{r}
loan$LogLoanAmount <- log(loan$LoanAmount)
loan$LogLoan_Amount_Term <- log(loan$Loan_Amount_Term)
```

```{r, echo=FALSE}
par(mfrow=c(1,2))
hist(loan$LoanAmount, 
     main="Histogram for Loan Amount", 
     xlab="Loan Amount", 
     border="black", 
     col="gray",
     las=1, 
     breaks=20, prob = TRUE)
hist(loan$LogLoanAmount, 
     main="Histogram for Log Loan Amount", 
     xlab="Loan Amount (transformed)", 
     border="black", 
     col="gray",
     las=1, 
     breaks=20, prob = TRUE)
```

Next, since there is a lot of relateability between the `ApplicantIncome` variable and `CoapplicantIncome` variable, we thought it would be best to combine these two variables to create an `Income` variable, and then perform a log transformation to obtain the best results.  

```{r}
loan$Income <- loan$ApplicantIncome + loan$CoapplicantIncome
loan$ApplicantIncome <- NULL
loan$CoapplicantIncome <- NULL
loan$LogIncome <- log(loan$Income)
```

When checking the new distribution of our `Income` variable, we can see that it is much more normally distributed:  

```{r, echo=FALSE}
hist(loan$LogIncome, 
     main="Histogram for Applicant Income", 
     xlab="Income", 
     border="black", 
     col="gray",
     las=1, 
     breaks=50, prob = TRUE)
```
With the exploratory data analysis behind us, and our data tidy'd, we are now ready to run our decision tree!  

***

***Splitting loan dataset into training and testing datasets***  

Similar to our KNN model process above, we'll determine an 80/20 split for our testing and training datasets:  

```{r}
set.seed(123)
train_sample<-sample(1:nrow(loan),size = floor(0.80*nrow(loan)))
train_loan<-loan[train_sample,]
test_loan<-loan[-train_sample,]
```

***

***Splitting loan dataset into training and testing datasets***  

With the data split, we can now run our first decision tree:  

```{r}
tree1 <- rpart(Loan_Status~Gender+Married+Dependents+Education+Self_Employed+LogIncome+LogLoanAmount+Loan_Amount_Term+Credit_History+Property_Area,data=train_loan)
rpart.plot(tree1,nn=TRUE)
summary(tree1)
```

From our decision tree summary and plot, we can see that a few variables, such as `Credit_History`, `Income` and `LoanAmount`, were important features in this classification method. We can use this decision tree to make predictions on our holdout test set.

```{r}
loanPre<-predict(tree1,test_loan,type="class")
table(loanPre,test_loan$Loan_Status)
accuracy<-mean(loanPre==test_loan$Loan_Status)
accuracy
```
As we can see from our predictions and the ensuing confusion matrix, we were able to obtain about 79% accuracy using this decision tree. To achieve higher accuracy, we'll use the `prune()` function in the `rpart` package to examine a predicted optimal tree size. 

```{r}
plotcp(tree1)
```
By plotting the cross-validated error against the complexity parameter, we can see that the relationship between the yields the best optimal outcome for our tree at a tree size of 2. 

```{r}
tree1$cptable
```
Although this is the case, when using this cp value in our `prune()` function, we still obtain accuracy ratings of around 79%. In order to test difference complexity parameters, we also decided to use our cp value of 0.41025641, which is a tree size of 1. When we use this tree size, and prune our initial tree accordingly, we can see the resulting decision tree below:  

```{r}
tree1.pruned <- prune(tree1, cp=0.41025641)
prp(tree1.pruned, type = 2, extra = 104, fallen.leaves = TRUE, main = "Decision Tree")
```
Interestingly, from this pruning process, the `Credit_History` feature alone seems to do a fairly good job of classifying applicants into the approval vs. disapproval status. The accuracy is about 83% on our test set, which is slightly higher than our initial tree.  

However, it's important to think critically about whether or not this pruned tree would perform better on another dataset, and if it is applicable for real-life events. 
```{r}
tree1.pruned.pred <- predict(tree1.pruned, test_loan, type = "class" )
tree1.pruned.perf <- table(test_loan$Loan_Status, tree1.pruned.pred, dnn = c("Actual", "Predicted"))

tree1.pruned.perf
accuracy<-mean(tree1.pruned.pred==test_loan$Loan_Status)
accuracy
```

In the end, we'd likely want to go with a more robust decision tree, than just one feature, but not getting too large in size -- which is why our initial tree seems to be a good balance between these two phenomenon.  

***

#### **Part 3: Random Forests on loan approval dataset**


***

**Using the same dataset on Loan Approval Status, please use Random Forests to predict on loan approval status. Again, please be sure to walk us through the steps you took to get to your final model. (50 points)**



```{r}
rf <- randomForest(Loan_Status~Gender+Married+Dependents+Education+Self_Employed+ApplicantIncome+CoapplicantIncome+LoanAmount+Loan_Amount_Term+Credit_History+Property_Area,data=train_loan)
rf
importance(rf)
```
```{r}
rfPre<-predict(rf,test_loan)
table(rfPre,test_loan$Loan_Status)
accuracy2<-mean(rfPre==test_loan$Loan_Status)
accuracy2
```


***

#### **Part 4: Gradient Boosting**


***

**Using the Loan Approval Status data, please use Gradient Boosting to predict on the loan approval status. Please use whatever boosting approach you deem appropriate;but please be sure to walk us through your steps. (50 points)**



***

#### **Part 5: Model Performance**


***

**Model performance: please compare the models you settled on for problem # 2 – 4.Comment on their relative performance. Which one would you prefer the most? Why?(20 points)**





